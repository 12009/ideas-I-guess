![Linux解决方案](https://github.com/MagnetoWang/ideas-I-guess/blob/master/markdown-for-document-organization-management/manage-pictures/linux-how-to-use.png)



## 说明

- 作为Windows的老用户，不得不说，Linux真难用！
- 作为计算机专业的我来说，Linux不得不学！



[TOC]



## 命令行问题

- ls：显示文件目录
- ll：显示文件目录详细信息
- cd：打开文件夹或者返回

## 文件常用操作

- cat：打开并显示文件

- tail：指定显示文件的几行内容

  - 从第5行开始显示文件 ：tail -n +5 log2014.log 

  - 循环查看文件内容 ：tail -f test.log ：配合其他命令边写边显示。效果佳

  - 显示文件最新的内容：tail -f filename ：和上面一样。理解程度不一样，用法不一样

  - 显示文件末尾5行内容 ：tail -n 5 log2014.log 

  - ```
    tail file （显示文件file的最后10行）
    tail +20 file （显示文件file的内容，从第20行至文件末尾）
    tail -c 10 file （显示文件file的最后10个字符）
    ```

- vim ：编辑文件，注意不要打开超大文件。非常吃内存

- more：http://man.linuxde.net/more：

  - 单开屏幕显示文件，更加详细查看内容

  - 按Space键：显示文本的下一屏内容。

  - 按Enier键：只显示文本的下一行内容。

  - 按斜线符`|`：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。

  - 按H键：显示帮助屏，该屏上有相关的帮助信息。

  - 按B键：显示上一屏内容。

  - 按Q键：退出rnore命令。

  - ```
    more -c -10 file
    ```

- less：http://man.linuxde.net/less

  - 类似more。但是more只能往下看，不能往上看
  - less可以向上和向下卡n

## 系统工具

- **系统**

  ```
  # uname -a               # 查看内核/操作系统/CPU信息
  # head -n 1 /etc/issue   # 查看操作系统版本
  # cat /proc/cpuinfo      # 查看CPU信息
  # hostname               # 查看计算机名
  # lspci -tv              # 列出所有PCI设备
  # lsusb -tv              # 列出所有USB设备
  # lsmod                  # 列出加载的内核模块
  # env                    # 查看环境变量
  ```

  **资源**

  ```
  # free -m                # 查看内存使用量和交换区使用量
  # df -h                  # 查看各分区使用情况
  # du -sh <目录名>        # 查看指定目录的大小
  # grep MemTotal /proc/meminfo   # 查看内存总量
  # grep MemFree /proc/meminfo    # 查看空闲内存量
  # uptime                 # 查看系统运行时间、用户数、负载
  # cat /proc/loadavg      # 查看系统负载
  ```

  **磁盘和分区**

  ```
  # mount | column -t      # 查看挂接的分区状态
  # fdisk -l               # 查看所有分区
  # swapon -s              # 查看所有交换分区
  # hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)
  # dmesg | grep IDE       # 查看启动时IDE设备检测状况
  ```

  **网络**

  ```
  # ifconfig               # 查看所有网络接口的属性
  # iptables -L            # 查看防火墙设置
  # route -n               # 查看路由表
  # netstat -lntp          # 查看所有监听端口
  # netstat -antp          # 查看所有已经建立的连接
  # netstat -s             # 查看网络统计信息
  ```

  **进程**

  ```
  # ps -ef                 # 查看所有进程
  # top                    # 实时显示进程状态
  ```

  **用户**

  ```
  # w                      # 查看活动用户
  # id <用户名>            # 查看指定用户信息
  # last                   # 查看用户登录日志
  # cut -d: -f1 /etc/passwd   # 查看系统所有用户
  # cut -d: -f1 /etc/group    # 查看系统所有组
  # crontab -l             # 查看当前用户的计划任务
  ```

  **服务**

  ```
  # chkconfig --list       # 列出所有系统服务
  # chkconfig --list | grep on    # 列出所有启动的系统服务
  ```

  **程序**

  ```
  # rpm -qa                # 查看所有安装的软件包
  ```



## Linux目录说明

- https://www.jianshu.com/p/fe8da5d08e16
- 

## 排查线上问题

### 性能工具

- top
  - 查询cpu情况：https://blog.csdn.net/GitChat/article/details/79019454
- free
  - 查询内存：-m,-g
  - 返回MB，GB格式
- dstat
  - 查询网络情况
  - -c  cpu 情况    -d 磁盘读写        -n 网络状况        -l 显示系统负载        -m 显示形同内存状况        -p 显示系统进程信息        -r 显示系统 IO 情况 

### 排除工具

- https://my.oschina.net/leejun2005/blog/1524687
- 

### 排查步骤

- 参考链接
  - https://tech.meituan.com/performance_tunning.html
  - https://blog.csdn.net/lipc_/article/details/52733651
- **紧急处理** 
  - **对于紧急的大面积故障，首先想到的不应该是检查问题。而是需要立刻追查最近线上系统是否有更改，我们的经验是****95%的故障都是在新代码上线后的12小时内发生的。此时应该立刻回滚新更改。另外5%****的故障大部分是由于业务扩展导致的。**互联网业有一个规律，线上系统每半年需要重构一次，否则无法对应业务量的增长。对于这种业务量增长造成的故障，通常可以通过重启服务来紧急处理。 
  - 因此，**紧急处理的首选是立刻回滚新更改。** 
- **添加监控** 
  - 紧急处理之后，服务已经恢复了，但是问题并没有找到。如果是新代码上线造成的故障，回滚之后，工程师会有各种手段，在测试环境追查问题。而针对系统容量不足造成的故障，需要特别添加监控作为追查问题的重要手段。因为互联网业务请求高峰和低谷差别非常明显，微博业务中的请求高峰往往出现在晚上10点左右，而且不是稳定的出现。 
- **JDK性能监控** 
- **分析源代码** 



## Java虚拟机排查问题

### 命令快速使用

- 打印进程使用虚拟机的每一代情况：jmap -J-d64 -heap pid
- 



### 排查工具

- jps -m 
  - 快速定位当前服务器运行的java进程，并给出路径



### 排查指标

- gc time
- gc count
- 各个分代的内存大小变化
- 机器的Load值与CPU使用率
- JVM的线程数
- gc log
- jstat等命令的输出 



# 美团文档内容-非常值得反复多看！

### 怎么调？

- 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。
- 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。
- 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用**jmap和MAT**，基本就能定位到具体的代码。



### 多线程与分布式

### 使用场景

离线任务、异步任务、大数据任务、耗时较长任务的运行**，适当地利用，可达到加速的效果。

注意：**线上对响应时间要求较高的场合，尽量少用多线程，尤其是服务线程需要等待任务线程的场合（很多重大事故就是和这个息息相关）**，如果一定要用，可以对服务线程设置一个最大等待时间。

### 常见做法

如果单机的处理能力可以满足实际业务的需求，那么尽可能地使用单机多线程的处理方式，减少复杂性；反之，则需要使用多机多线程的方式。

对于**单机多线程**，可以引入**线程池**的机制，作用有二：

- **提高性能，节省线程创建和销毁的开销**
- **限流，给线程池一个固定的容量，达到这个容量值后再有任务进来，就进入队列进行排队，保障机器极限压力下的稳定处理能力**在使用JDK自带的线程池时，一定要仔细理解构造方法的各个参数的含义，如**core pool size、max pool size、keepAliveTime、worker queue**等，在理解的基础上通过不断地测试调整这些参数值达到最优效果。

如果单机的处理能力不能满足需求，这个时候需要使用**多机多线程**的方式。这个时候就需要一些分布式系统的知识了。首先就必须引入一个单独的节点，作为调度器，其他的机器节点都作为执行器节点。调度器来负责拆分任务，和分发任务到合适的执行器节点；执行器节点按照多线程的方式（也可能是单线程）来执行任务。这个时候，我们整个任务系统就由单击演变成一个集群的系统，而且不同的机器节点有不同的角色，各司其职，各个节点之间还有交互。这个时候除了有多线程、线程池等机制，像RPC、心跳等网络通信调用的机制也不可少。后续我会出一个简单的分布式调度运行的框架。

## 度量系统（监控、报警、服务依赖管理）

严格来说，度量系统不属于性能优化的范畴，但是这方面和性能优化息息相关，可以说为性能优化提供一个强有力的数据参考和支撑。没有度量系统，基本上就没有办法定位到系统的问题，也没有办法有效衡量优化后的效果。很多人不重视这方面，但我认为它是系统稳定性和性能保障的基石。

### 关键流程

如果要设计这套系统，总体来说有哪些关键流程需要设计呢？
① 确定指标
② 采集数据
③ 计算数据，存储结果
④ 展现和分析

### 需要监控和报警哪些指标数据？需要关注哪些？

按照需求出发，主要需要二方面的指标：

1. 接口性能相关，包括单个接口和全部的QPS、响应时间、调用量（统计时间维度越细越好；最好是，既能以节点为维度，也可以以服务集群为维度，来查看相关数据）。其中还涉及到服务依赖关系的管理，这个时候需要用到服务依赖管理系统
2. 单个机器节点相关，包括CPU使用率、Load值、内存占用率、网卡流量等。如果节点是一些特殊类型的服务（比如MySQL、Redis、Tair），还可以监控这些服务特有的一些关键指标。

### 数据采集方式

通常采用异步上报的方式，具体做法有两种：第一种，发到本地的Flume端口，由Flume进程收集到远程的Hadoop集群或者Storm集群来进行运算；第二种，直接在本地运算好以后，使用异步和本地队列的方式，发送到监控服务器。

### 数据计算

可以采用离线运算（MapReduce/Hive）或者实时/准实时运算（Storm/Spark）的方式，运算后的结果存入MySQL或者HBase；某些情况，也可以不计算，直接采集发往监控服务器。

### 展现和分析

提供统一的展现分析平台，需要带报表（列表/图表）监控和报警的功能。

# 真实案例分析

## 案例一：商家与控制区关系的刷新job

### 背景

这是一个每小时定期运行一次的job，作用是用来刷新商家与控制区的关系。具体规则就是根据商家的配送范围（多个）与控制区是否有交集，如果有交集，就把这个商家划到这个控制区的范围内。

### 业务需求

需要这个过程越短越好，最好保持在20分钟内。

### 优化过程

原有代码的主要处理流程是：

1. 拿到所有门店的配送范围列表和控制区列表。
2. 遍历控制区列表，针对每一个控制区：
   a. 遍历商家的配送范围列表，找到和这个控制区相交的配送范围列表。
   b. 遍历上述商家配送范围列表，对里面的商家ID去重，保存到一个集合里。
   c. 批量根据上述商家ID集合，取到对应的商家集合。
   d. 遍历上述商家集合，从中拿到每一个商家对象，进行相应的处理（根据是否已是热门商家、自营、在线支付等条件来判断是否需要插入或者更新之前的商家和控制区的关系）。
   e. 删除这个控制区当前已有的，但是不应该存在的商家关系列表。

分析代码，发现第2步的a步骤和b步骤，找出和某控制区相交的配送范围集合并对商家ID去重，可以采用R树空间索引的方式来优化。具体做法是：

- 任务开始先更新R树，然后利用R树的结构和匹配算法来拿到和控制区相交的配送范围ID列表。
- 再批量根据配送范围ID列表，拿到配送范围列表。
- 然后针对这一批配送范围列表（数量很小），用原始多边形相交匹配的方法做进一步过滤，并且对过滤后的商家ID去重。

这个优化已经在第一期优化中上线，整个过程耗时**由40多分钟缩短到20分钟以内**。

第一期优化改为R树以后，运行了一段时间，随着数据量增大，性能又开始逐渐恶化，一个月后已经恶化到50多分钟。于是继续深入代码分析，寻找了两个优化点，安排第二期优化并上线。

这两个优化点是：

- 第2步的c步骤，原来是根据门店ID列表从DB批量获取门店，现在可以改成mget的方式从缓存批量获取（此时商家数据已被缓存）；
- 第2步的d步骤，根据是否已是热门商家、自营、在线支付等条件来判断是否需要插入或者更新之前的商家和控制区的关系。

### 上线后效果

通过日志观察，执行时间**由50多分钟缩短到15分钟以内**，下图是截取了一天的4台机器的日志时间（单位：**毫秒**）：
![poi优化效果图](https://tech.meituan.com/img/poi%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE.png)
可以看到，效果还是非常明显的。

## 案例二：POI缓存设计与实现

### 背景

2014年Q4，数据库中关于POI（这里可以简单理解为外卖的门店）相关的数据的**读流量**急剧上升，虽然说加入从库节点可以解决一部分问题，但是毕竟节点的增加是会达到极限的，达到极限后主从复制会达到瓶颈，可能会造成数据不一致。所以此时，急需引入一种新的技术方案来分担数据库的压力，降低数据库POI相关数据的读流量。另外，任何场景都考虑加DB从库的做法，会对资源造成一定的浪费。

### 实现方案

基于已有的经过考验的技术方案，我选择Tair来作为缓存的存储方案，来帮DB分担来自于各应用端的POI数据的读流量的压力。理由主要是从**可用性、高性能、可扩展性、是否经过线上大规模数据和高并发流量的考验、是否有专业运维团队、是否有成熟工具**等几个方面综合考量决定。

### 详细设计

#### 第一版设计

缓存的更新策略，根据业务的特点、已有的技术方案和实现成本，选择了用MQ来接收POI改变的消息来触发缓存的更新，但是这个过程有可能失败；同时启用了key的过期策略，并且调用端会先判断是否过期，如过期，会从后端DB加载数据并回设到缓存，再返回。通过两个方面双保险确保了缓存数据的可用。

#### 第二版设计

第一版设计运行到一段时间以后，我们发现了两个问题：

1. 某些情况下不能保证数据的实时一致（比如技术人员手动改动DB数据、利用MQ更新缓存失败），这个时候只能等待5分钟的过期时间，有的业务是不允许的。
2. 加入了过期时间导致另外一个问题：Tair在缓存不命中的那一刻，会尝试从硬盘中Load数据，如果硬盘没有再去DB中Load数据。这无疑会进一步延长Tair的响应时间，这样不仅使得业务的超时比率加大，而且会导致Tair的性能进一步变差。

为了解决上述问题，我们从美团点评负责基础架构的同事那里了解到[Databus](https://github.com/linkedin/databus)可以解决缓存数据在某些情况下不一致的问题，并且可以去掉过期时间机制，从而提高查询效率，避免tair在内存不命中时查询硬盘。而且为了防止DataBus单点出现故障影响我们的业务，我们保留了之前接MQ消息更新缓存的方案，作了切换开关，利用这个方案作容错，整体架构如下：
![poi缓存设计图](https://tech.meituan.com/img/poi%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E5%9B%BE.png)

### 上线后效果

上线后，通过持续地监控数据发现，随着调用量的上升，到DB的流量有了明显地减少，极大地减轻了DB的压力。同时这些数据接口的响应时间也有了明显地减少。缓存更新的双重保障机制，也基本保证了缓存数据的可用。见下图：
![poi缓存优化效果图_1](https://tech.meituan.com/img/poi%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_1.png)
![poi缓存优化效果图](https://tech.meituan.com/img/poi%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE.png)

## 案例三：业务运营后台相关页面的性能优化

### 背景

随着业务的快速发展，带来的访问量和数据量的急剧上升，通过我们相应的监控系统可以发现，系统的某些页面的性能开始出现恶化。 从用户方的反馈，也证明了这点。此时此刻，有必要迅速排期，敏捷开发，对这些页面进行调优。

### 欢迎页

- 需求背景：欢迎页是地推人员乃至总部各种角色人员进入外卖运营后台的首页，会显示地推人员最想看到最关心的一些核心数据，其重要性不言而喻，所以该页面的性能恶化会严重影响到用户体验。因此，首先需要优化的就是欢迎页。通过相应定位和分析，发现导致性能恶化的主要原因有两个：数据接口层和计算展现层。
- 解决方案：对症下药，分而治之。经过仔细排查、分析定位，数据接口层采用接口调用批量化、异步RPC调用的方式来进行有效优化，计算展现层决定采用预先计算、再把计算好的结果缓存的方式来提高查询速度。其中，缓存方案根据业务场景和技术特点，选用Redis。定好方案后，快速开发上线。
- 上线效果：上线后性能对比图，如下：
  ![优化效果图_1](https://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_1.png)

### 组织架构页

- 需求背景：组织架构页，采用了四层树形结构图，一起呈现加载，第一版上线后发现性能非常差。用户迫切希望对这个页面的性能进行调优。
- 解决方案：经过分析代码，定位到一个比较经典的问题：里面执行了太多次小数据量的SQL查询。于是采用多个SQL合并成大SQL的方式，然后使用本地缓存来缓存这些数据，合理预估数据量和性能，充分测试后上线。
- 上线效果：上线后性能对比图，如下：
  ![优化效果图_2](https://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_2.png)

### 订单关联楼宇页

- 需求背景：随着订单量日益增大，订单表积累的数据日益增多，订单关联楼宇页的性能也日益变差（响应时间线性上升）。而这个页面和地推人员的业绩息息相关，所以地推人员使用该页面的频率非常高，性能日益恶化极大地影响了地推人员的用户体验。
- 解决方案：经过分析与设计，决定采用当时已有的订单二级索引月分表来代替原始的订单表来供前端的查询请求；并且限制住筛选的时间条件，使得筛选的开始时间和结束时间不能跨月（事先和用户沟通过，可以接受，能满足用户的基本需求），这样就只需一个月分索引表即可，通过适当的功能限制来达到性能的调优。这样从二级索引月分表中根据各种查询条件查到最终的分页的订单ID集合，然后再根据订单ID从订单库来查出相应的订单数据集合。
- 上线效果：上线后发现在调用量几乎没怎么变的情况下，性能提升明显，如下图：
  ![优化效果图_3](https://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_3.png)

## 其他

除了上面介绍的之外，优化还涉及前端、分布式文件系统、CDN、全文索引、空间索引等几方面。限于篇幅，我们留到未来再做介绍。





# Linux基础

## 基本概念

- POSIX：https://en.wikipedia.org/wiki/POSIX
  - The Portable Operating System Interface (POSIX)



## 基本操作

- vim
  - 保存退出：:wq
  - 不保存退出：:q!
  - 
- make
  - 默认编译makefile
  - -j5：同时运行5个jobs
- cmake

  - 默认编译CMakeLists.txt
- 查看系统编码

  - locale：https://blog.csdn.net/jbxue123/article/details/17909913
- 一切皆文件

  - lsof ：https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html
- top
  - 查看cpu占用率
- vscode同步服务器
  - https://www.jianshu.com/p/390c68a0cc58
- date -R
  - 查看当前时区
  - https://www.cnblogs.com/h2appy/archive/2008/11/27/1342029.html
- ip address
  - 查看本机ip地址
- kill -s 9 pid
  - 杀死进程
- netstat -an | grep 6181 
  - 查看端口
  - lsof -i;2181
  - 查看端口
- cp sourceDir destDir
  - 复制文件
  - 同时可以修改名字



## 基本功能

- 查询系统版本
  -  cat /proc/version
  - https://www.qiancheng.me/post/coding/show-linux-issue-version

- 安装java和配置路径

  - wget http://pkg.4paradigm.com/jdk/jdk-8u141-linux-x64.tar.gz
  - 解压：https://blog.csdn.net/FX677588/article/details/76100538
  - tar -zxvf ×××.tar.gz
  - vi ~/.bash_profile
  - export JAVA_HOME=/home/wangzixian/java/jdk1.8.0_141/bin/java
  - export PATH=$PATH:/home/wangzixian/java/jdk1.8.0_141/bin
  - source ~/.bash_profile
  - https://www.cyberciti.biz/faq/linux-unix-set-java_home-path-variable/

- 安装和配置maven和路径

  - https://www.baeldung.com/install-maven-on-windows-linux-mac

  - http://maven.apache.org/download.cgi

  - ```
    export JAVA_HOME=/home/wangzixian/java/jdk1.8.0_141
    export JRE_HOME=home/wangzixian/java/jdk1.8.0_141/jre
    export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib
    export PATH=$PATH:/home/wangzixian/java/jdk1.8.0_141/bin
    
    export MAVEN_HOME=/home/wangzixian/maven/apache-maven-3.5.4
    export PATH=${MAVEN_HOME}/bin:${PATH}
    ```

  - mvn -X 可以查看settings.xml路径位置

- 打开文件

  - 显示行号：http://blog.sina.com.cn/s/blog_716844910100tfxv.html
  - cat -n filename

- 性能查找

  - https://www.cnblogs.com/emanlee/p/3587571.html

- 解压

  - tar -zxvf ×××.tar.gz
  - tar -jxvf ×××.tar.bz2
  - https://blog.csdn.net/FX677588/article/details/76100538

- 安装zsh

  - https://harttle.land/2016/10/25/install-oh-my-zsh-locally.html
  - 全路径显示：https://blog.csdn.net/s_gy_zetrov/article/details/80158409




## Linux下的C++

### 基本编译运行

- g++ helloworld.cpp -o helloworld
- ./helloworld

### 复杂文件编译运行

- 



[TOC]

