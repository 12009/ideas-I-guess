![Linux解决方案](https://github.com/MagnetoWang/ideas-I-guess/blob/master/markdown-for-document-organization-management/manage-pictures/linux-how-to-use.png)



## 说明

- 作为Windows的老用户，不得不说，Linux真难用！
- 作为计算机专业的我来说，Linux不得不学！



## 命令行问题

- ls：显示文件目录
- ll：显示文件目录详细信息
- cd：打开文件夹或者返回

## 文件常用操作

- cat：打开并显示文件

- tail：指定显示文件的几行内容

  - 从第5行开始显示文件 ：tail -n +5 log2014.log 

  - 循环查看文件内容 ：tail -f test.log ：配合其他命令边写边显示。效果佳

  - 显示文件最新的内容：tail -f filename ：和上面一样。理解程度不一样，用法不一样

  - 显示文件末尾5行内容 ：tail -n 5 log2014.log 

  - ```
    tail file （显示文件file的最后10行）
    tail +20 file （显示文件file的内容，从第20行至文件末尾）
    tail -c 10 file （显示文件file的最后10个字符）
    ```

- vim ：编辑文件，注意不要打开超大文件。非常吃内存

- more：http://man.linuxde.net/more：

  - 单开屏幕显示文件，更加详细查看内容

  - 按Space键：显示文本的下一屏内容。

  - 按Enier键：只显示文本的下一行内容。

  - 按斜线符`|`：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。

  - 按H键：显示帮助屏，该屏上有相关的帮助信息。

  - 按B键：显示上一屏内容。

  - 按Q键：退出rnore命令。

  - ```
    more -c -10 file
    ```

- less：http://man.linuxde.net/less

  - 类似more。但是more只能往下看，不能往上看
  - less可以向上和向下卡n

## 系统工具

- **系统**

  ```
  # uname -a               # 查看内核/操作系统/CPU信息
  # head -n 1 /etc/issue   # 查看操作系统版本
  # cat /proc/cpuinfo      # 查看CPU信息
  # hostname               # 查看计算机名
  # lspci -tv              # 列出所有PCI设备
  # lsusb -tv              # 列出所有USB设备
  # lsmod                  # 列出加载的内核模块
  # env                    # 查看环境变量
  ```

  **资源**

  ```
  # free -m                # 查看内存使用量和交换区使用量
  # df -h                  # 查看各分区使用情况
  # du -sh <目录名>        # 查看指定目录的大小
  # grep MemTotal /proc/meminfo   # 查看内存总量
  # grep MemFree /proc/meminfo    # 查看空闲内存量
  # uptime                 # 查看系统运行时间、用户数、负载
  # cat /proc/loadavg      # 查看系统负载
  ```

  **磁盘和分区**

  ```
  # mount | column -t      # 查看挂接的分区状态
  # fdisk -l               # 查看所有分区
  # swapon -s              # 查看所有交换分区
  # hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)
  # dmesg | grep IDE       # 查看启动时IDE设备检测状况
  ```

  **网络**

  ```
  # ifconfig               # 查看所有网络接口的属性
  # iptables -L            # 查看防火墙设置
  # route -n               # 查看路由表
  # netstat -lntp          # 查看所有监听端口
  # netstat -antp          # 查看所有已经建立的连接
  # netstat -s             # 查看网络统计信息
  ```

  **进程**

  ```
  # ps -ef                 # 查看所有进程
  # top                    # 实时显示进程状态
  ```

  **用户**

  ```
  # w                      # 查看活动用户
  # id <用户名>            # 查看指定用户信息
  # last                   # 查看用户登录日志
  # cut -d: -f1 /etc/passwd   # 查看系统所有用户
  # cut -d: -f1 /etc/group    # 查看系统所有组
  # crontab -l             # 查看当前用户的计划任务
  ```

  **服务**

  ```
  # chkconfig --list       # 列出所有系统服务
  # chkconfig --list | grep on    # 列出所有启动的系统服务
  ```

  **程序**

  ```
  # rpm -qa                # 查看所有安装的软件包
  ```



## Linux目录说明

- https://www.jianshu.com/p/fe8da5d08e16
- 

## 排查线上问题

### 性能工具

- top
  - 查询cpu情况：https://blog.csdn.net/GitChat/article/details/79019454
- free
  - 查询内存：-m,-g
  - 返回MB，GB格式
- dstat
  - 查询网络情况
  - -c  cpu 情况    -d 磁盘读写        -n 网络状况        -l 显示系统负载        -m 显示形同内存状况        -p 显示系统进程信息        -r 显示系统 IO 情况 

### 排除工具

- https://my.oschina.net/leejun2005/blog/1524687
- 

### 排查步骤

- 参考链接
  - https://tech.meituan.com/performance_tunning.html
  - https://blog.csdn.net/lipc_/article/details/52733651
- **紧急处理** 
  - **对于紧急的大面积故障，首先想到的不应该是检查问题。而是需要立刻追查最近线上系统是否有更改，我们的经验是****95%的故障都是在新代码上线后的12小时内发生的。此时应该立刻回滚新更改。另外5%****的故障大部分是由于业务扩展导致的。**互联网业有一个规律，线上系统每半年需要重构一次，否则无法对应业务量的增长。对于这种业务量增长造成的故障，通常可以通过重启服务来紧急处理。 
  - 因此，**紧急处理的首选是立刻回滚新更改。** 
- **添加监控** 
  - 紧急处理之后，服务已经恢复了，但是问题并没有找到。如果是新代码上线造成的故障，回滚之后，工程师会有各种手段，在测试环境追查问题。而针对系统容量不足造成的故障，需要特别添加监控作为追查问题的重要手段。因为互联网业务请求高峰和低谷差别非常明显，微博业务中的请求高峰往往出现在晚上10点左右，而且不是稳定的出现。 
- **JDK性能监控** 
- **分析源代码** 



## Java虚拟机排查问题

### 排查工具

- jps -m 
  - 快速定位当前服务器运行的java进程，并给出路径



### 排查指标

- gc time
- gc count
- 各个分代的内存大小变化
- 机器的Load值与CPU使用率
- JVM的线程数
- gc log
- jstat等命令的输出 



## 美团文档内容-非常值得反复多看！

### 怎么调？

- 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。
- 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。
- 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用**jmap和MAT**，基本就能定位到具体的代码。



### 多线程与分布式

### 使用场景

离线任务、异步任务、大数据任务、耗时较长任务的运行**，适当地利用，可达到加速的效果。

注意：**线上对响应时间要求较高的场合，尽量少用多线程，尤其是服务线程需要等待任务线程的场合（很多重大事故就是和这个息息相关）**，如果一定要用，可以对服务线程设置一个最大等待时间。

### 常见做法

如果单机的处理能力可以满足实际业务的需求，那么尽可能地使用单机多线程的处理方式，减少复杂性；反之，则需要使用多机多线程的方式。

对于**单机多线程**，可以引入**线程池**的机制，作用有二：

- **提高性能，节省线程创建和销毁的开销**
- **限流，给线程池一个固定的容量，达到这个容量值后再有任务进来，就进入队列进行排队，保障机器极限压力下的稳定处理能力**在使用JDK自带的线程池时，一定要仔细理解构造方法的各个参数的含义，如**core pool size、max pool size、keepAliveTime、worker queue**等，在理解的基础上通过不断地测试调整这些参数值达到最优效果。

如果单机的处理能力不能满足需求，这个时候需要使用**多机多线程**的方式。这个时候就需要一些分布式系统的知识了。首先就必须引入一个单独的节点，作为调度器，其他的机器节点都作为执行器节点。调度器来负责拆分任务，和分发任务到合适的执行器节点；执行器节点按照多线程的方式（也可能是单线程）来执行任务。这个时候，我们整个任务系统就由单击演变成一个集群的系统，而且不同的机器节点有不同的角色，各司其职，各个节点之间还有交互。这个时候除了有多线程、线程池等机制，像RPC、心跳等网络通信调用的机制也不可少。后续我会出一个简单的分布式调度运行的框架。



