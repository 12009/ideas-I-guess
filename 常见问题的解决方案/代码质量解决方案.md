## 代码质量解决方案

- 代码的质量决定一个软件的生死
- 如何测试代码就是在找病因
- 如何自动化测试代码就是如何保证代码长久稳定茁壮成长

[TOC]



## 测试用例的设计

- 测试代码的状态
  - 可实现
  - 未知
  - 探索中
  - 不可实现



## 测试用例的实现

- 要明白测试的变量是什么
  - 先找变量，比如check_binlog_sync_progress_delta
- 要明白测试的结果
  - 确定好标志性的变量即可，比如状态的alive
- 明白测试的步骤
  - 这里要设计好，必须是可实现的代码才行



## 测试过程案例

### showTable

- 测试点：showtable显示offset, record_cnt和memused
  - 变量是offset, record_cnt和memused
- 结果：
  - 数据和gettablestatus一致
  - showtable可以显示offset、record_cnt和memused
  - 直接用assert函数判断即可
- 测试步骤
  - 创建表
    - 可实现
  - put数据
    - 可实现
  - showtable
    - 可实现
  - 到tablet执行gettablestatus看offset是否一致
    - 比较麻烦
  - assert判断
    - 可实现
- 目标明确后可以，直接操作上手代码了



- 测试点：兼容性测试
  - 变量：不同的版本软件
- 结果
  - 数据显示均正常
- 测试步骤
  - 1.3.10 nsclient连1.3.7nameserver，然后showtable
  - 1.3.7nsclient连1.3.10nameserve，然后showtable
- 经过咨询，改测试难度过大，不可能写入自动化测试，所以不写



### cancelop

- 测试点：状态为inited的op可以cancel
  - 变量：op的状态
- 结果
  - 状态改变成canceled
- 测试步骤
  - 创建32分片的表
    - 可实现
  - 执行offliendpoint endpoint 1
    - 未知
    - 探索中
    - 可行
  - 找到inited的opid
    - 未知
    - 探索中
  - 执行cancelop op_id
    - 可行
- 咨询之后，第三步的执行操作，目前比较麻烦，暂时搁置

### Auto_failover

#### 1
- 测试点：auto_failover开启时不能执行offlineendpoint
  - 变量：auto_failover
- 结果
  - 执行离线操作会失败
- 测试步骤
  - confset auto_failover true
    - 可行
  - offlineendpoint {endpoint}
    - 可行
- 可以实现
#### 2
- 测试点：auto_failover开启时不能执行recoverendpoint
  - 变量：auto_failover
- 结果
  - 执行离线操作会失败
- 测试步骤
  - confset auto_failover true
    - 可行
  - recoverendpoint {endpoint}
    - 可行
- 可以实现

#### 3

- 测试点：autofailover开启时重启节点可以自动恢复
  - 变量：autofailover
- 结果
  - table 的 alive 变成yes
- 测试步骤
  - confset auto_failover true
    - 可行
  - create table
    - 可行
  - put一定数据
    - 可行
  - 下线一个tablet节点
    - 可行
  - 重启节点
    - 探索中
- 

