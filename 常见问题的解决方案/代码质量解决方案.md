代码质量解决方案

- 代码的质量决定一个软件的生死
- 如何测试代码就是在找病因
- 如何自动化测试代码就是如何保证代码长久稳定茁壮成长

[TOC]



## 测试用例的设计

- 测试代码的状态
  - 可实现
  - 未知
  - 探索中
  - 不可实现



## 测试用例的实现

- 要明白测试的变量是什么
  - 先找变量，比如check_binlog_sync_progress_delta
- 要明白测试的结果
  - 确定好标志性的变量即可，比如状态的alive
- 明白测试的步骤
  - 这里要设计好，必须是可实现的代码才行
- 测试用例的约束条件
  - 每个测试用例都应该互不干涉
  - 每个测试用例都不能把全局条件更改，导致另外的测试用例出错
  - 比如，下线某个leader节点和副本节点。就会导致下一个测试用例无法正常创建表
- 测试结果唯一性
  - 在出现可能出现多个状态的结果的时候，单一的比较对象结果，并不一定是正确测试方案
  - 比如，在一个表中有多个副本，不断表所在的服务器，最后一个服务器将不会改变状态
  - 这个时候如果只比较是否存在一个alive的服务器是不行的
  - 三个服务器，有一个存活的状态，另外两个都是dead状态
  - 但是也有可能有两个存活状态，或者三个存活状态。只比较服务器有存活机器，是不能得到背后真正的结果。应该每个服务器的状态都要比较。保证存在且只有一台服务器存活才行。

## 测试技巧

- 针对不确定等待多长时间的，为了包含它的等待限度同时具有弹性等待如何解决呢
  - 用循环，每次循环等待1秒，控制循环参数
  - 满足条件立刻跳出去

## 测试过程案例

### showTable

- 测试点：showtable显示offset, record_cnt和memused
  - 变量是offset, record_cnt和memused
- 结果：
  - 数据和gettablestatus一致
  - showtable可以显示offset、record_cnt和memused
  - 直接用assert函数判断即可
- 测试步骤
  - 创建表
    - 可实现
  - put数据
    - 可实现
  - showtable
    - 可实现
  - 到tablet执行gettablestatus看offset是否一致
    - 比较麻烦
  - assert判断
    - 可实现
- 目标明确后可以，直接操作上手代码了



- 测试点：兼容性测试
  - 变量：不同的版本软件
- 结果
  - 数据显示均正常
- 测试步骤
  - 1.3.10 nsclient连1.3.7nameserver，然后showtable
  - 1.3.7nsclient连1.3.10nameserve，然后showtable
- 经过咨询，改测试难度过大，不可能写入自动化测试，所以不写



### cancelop

- 测试点：状态为inited的op可以cancel
  - 变量：op的状态
- 结果
  - 状态改变成canceled
- 测试步骤
  - 创建32分片的表
    - 可实现
  - 执行offliendpoint endpoint 1
    - 未知
    - 探索中
    - 可行
  - 找到inited的opid
    - 未知
    - 探索中
  - 执行cancelop op_id
    - 可行
- 咨询之后，第三步的执行操作，目前比较麻烦，暂时搁置

### Auto_failover

#### 1
- 测试点：auto_failover开启时不能执行offlineendpoint
  - 变量：auto_failover
- 结果
  - 执行离线操作会失败
- 测试步骤
  - confset auto_failover true
    - 可行
  - offlineendpoint {endpoint}
    - 可行
- 可以实现
#### 2
- 测试点：auto_failover开启时不能执行recoverendpoint
  - 变量：auto_failover
- 结果
  - 执行离线操作会失败
- 测试步骤
  - confset auto_failover true
    - 可行
  - recoverendpoint {endpoint}
    - 可行
- 可以实现

#### 3

- 测试点：autofailover开启时重启节点可以自动恢复
  - 变量：autofailover
- 结果
  - table 的 alive 变成yes
- 测试步骤
  - confset auto_failover true
    - 可行
  - create table
    - 可行
  - put一定数据
    - 可行
  - 下线一个tablet节点
    - 可行
  - 重启节点
    - 探索中
    - 咨询后，不是offlineendpoint函数
    - 而是kill 一个节点
    - 然后start 一个节点
- kill和start不好把握，理解不到位，还要继续咨询才能明白测试的点

#### 4

- 测试点：开启时节点下线，然后nameserver切换后超时时间内节点恢复
  - 变量：autofailover，nameserver
- 结果
  - 恢复后的table 的 offset 和 leader 保持一致
- 测试步骤
  - confset auto_failover true
  - create table
  - put一定数据
  - 下线一个tablet节点
    - 以上可行
  - kill nameserver leader
    - 探索中
    - showns无法定位内容
  - 超时时间内恢复节点
    - 探索中
- 探索后，发现可以实现，需要细心

#### 5

- 测试点：三副本最后一个节点下线没有做故障切换
  - 节点的is_alive
- 结果
  - 下线三个节点后，最后一个节点仍然保持存活状态
- 测试步骤
  - confset auto_failover true
  - create table
  - put一定数据
    - 以上可行
  - disconnectzk endpoint1
    - 探索中
    - 不是stop_client函数
    - 是disconnectzk()
  - disconnectzk endpoint2
  - disconnectzk endpoint3
    - 探索后，发现更准确的函数。理解到位才能提高效率继续往下写
  - showtable观察tablet的存活情况和状态
    - 可行
- showtable应该查询所有服务器的状态，才能得到唯一的解

#### 6

- 测试点：任务执行超时后打印日志
  - 变量：任务执行时间
- 结果
  - 会有日志打印，关于任务超时的问题
- 测试步骤
  - 修改任务超时时间name_server_op_execute_timeout为10秒(默认两小时)
    - ns ？ Tablet conf
  - create table
    - 可行
  - put20w+数据
    - 不可行
  - addreplica
    - 探索中
    - 可行
  - showopstatus
    - 可行
  - 查看nameserver日志关键词为"The executeion time of op is too long"
    - 探索中

#### 7

- 测试点：闪断一个tablet
  - 变量：中断tablet的连接
- 结果
  - 没有做故障迁移，主从关系正常
    - 探索中
- 测试步骤
  - disconnectzk
    - 可行
  - connectzk
    - 可行
- 是否做自动恢复呢



#### 8

- 测试点：连续两次重启同一个tablet
  - 重启tablet的次数
- 结果
  - 第二次重启后数据恢复正常，主从关系正常
    - 探索中
    - 第一次和最后一次的结果转换字符串然后比较
- 测试步骤
  - create table
  - put数据
  - 停止一个tablet
  - 重启一个tablet
  - 数据恢复好之后
  - 再重启一下
    - 以上可行
- 经过咨询，要加上 停止一个tablet 这个测试步骤才行



9

- 测试点：





